// import say from 'say';
import axios, { AxiosRequestConfig } from 'axios';
import { exec } from 'child_process';
import fs from 'fs';
import path from 'path';
let ELEVENVLABS_API_KEY: string = process.env.ELEVENLABS_API_KEY!;
if (typeof ELEVENVLABS_API_KEY === 'undefined')
  throw new Error('ELEVENLABS_API_KEY is not defined');
const url = 'https://api.elevenlabs.io/v1/';
export const maleVoices = [
  'yoZ06aMxZJJ28mfd3POQ',
  'pNInz6obpgDQGcFmaJgB',
  'VR6AewLTigWG4xSOukaG',
  'TxGEqnHWrfWFTfGW9XjX',
  'ErXwobaYiN019PkySvjV',
  'AZnzlk1XvdvUeBnXmlld',
];
export const femaleVoices = [
  '21m00Tcm4TlvDq8ikWAM',
  'EXAVITQu4vr4xnSDxMaL',
  'MF3mGyEYCl7XYWbV9V6O',
];
export type FemaleVoice = (typeof femaleVoices)[number];
export type MaleVoice = (typeof maleVoices)[number];
// combine both types
export type Voices = FemaleVoice | MaleVoice;

// Generated by https://quicktype.io

export interface GetVoicesResponse {
  voices: Voice[];
}

export interface Voice {
  voice_id: string;
  name: string;
  samples: null;
  category: string;
  fine_tuning: FineTuning;
  labels: Labels;
  description: null;
  preview_url: string;
  available_for_tiers: any[];
  settings: null;
}

export interface FineTuning {
  model_id: null;
  is_allowed_to_fine_tune: boolean;
  fine_tuning_requested: boolean;
  finetuning_state: string;
  verification_attempts: null;
  verification_failures: any[];
  verification_attempts_count: number;
  slice_ids: null;
}

export interface Labels {}

// /v1/text-to-speech/{voice_id}
export const ElevenLabsAPI = {
  voices: `${url}voices`,
  textToSpeech: (voice: string) => `${url}text-to-speech/${voice}`,
  textToSpeechStream: (voice: string) => `${url}text-to-speech/${voice}/stream`,
};
/**
 *
 * @param soundFile Sound file with full path and extension
 * @param outputExtension
 */
export const convertFFMPEG = async (
  soundFile: string,
  outputExtension: string,
) => {
  const outputFileName = soundFile.replace(/\.[^/.]+$/, '');
  const outputFilePath = `${outputFileName}.${outputExtension}`;
  const command = `ffmpeg -i ${soundFile} -acodec libmp3lame -ab 64k ${outputFilePath}`;
  await new Promise((resolve, reject) => {
    exec(command, (err) => {
      if (err) reject(err);
      resolve(null);
    });
  });
  return outputFilePath;
};

export const getVoices = async () => {
  let headers = new Headers();
  let apiKey = process.env.ELEVENLABS_API_KEY;
  headers.append('xi-api-key', apiKey as string);

  const res = await fetch(ElevenLabsAPI.voices, {
    method: 'GET',
    headers,
  });
  if (!res.ok) throw new Error(res.statusText);
  let voices = ((await res.json()) as GetVoicesResponse).voices;
  return voices;
};

// get type of female voices

/*
Schema:
{
  "text": "string",
  "voice_settings": {
    "stability": 0,
    "similarity_boost": 0
  }
}
*/
export interface TextToSpeechRequest {
  text: string;
  voice: Voices;
}
const generateSpeech = async (text: string, voice: Voices) => {
  var options: AxiosRequestConfig = {
    method: 'POST',
    url: ElevenLabsAPI.textToSpeech(voice),
    headers: {
      'Content-Type': 'application/json',
      'xi-api-key': ELEVENVLABS_API_KEY,
    },
    data: {
      text: text,
      voice_settings: { stability: 0, similarity_boost: 0 },
    },
    responseType: 'stream',
  };

  const res = await axios.request(options).catch((err) => {
    throw new Error(err.response.data.statusMessage);
  });
  const soundPath = `./public/generatedVoices/${Date.now()}.mpeg`;
  // create path if it doesn't exist
  if (!fs.existsSync(path.dirname(soundPath)))
    fs.mkdirSync(path.dirname(soundPath), { recursive: true });

  const writeStream = fs.createWriteStream(soundPath);
  res.data.pipe(writeStream);
  await new Promise((resolve, reject) => {
    writeStream.on('finish', resolve);
    writeStream.on('error', reject);
  });
  const convertedSoundPath = await convertFFMPEG(soundPath, 'mp3');
  return convertedSoundPath;
};

// export default speak;

export default generateSpeech;
